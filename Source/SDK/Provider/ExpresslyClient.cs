using System;
using System.Collections.Generic;
using System.Net;
using Expressly.Log;
using System.Text;
using System.Threading;

namespace Expressly.Api
{
    /// <summary>
    /// Abstract class that handles configuring an HTTP request prior to making an API call.
    /// </summary>
    public abstract class ExpresslyClient : ExpresslySerializableObject
    {
        /// <summary>
        /// Logs output statements, errors, debug info to a text file    
        /// </summary>
        private static Logger logger = Logger.GetLogger(typeof(ExpresslyClient));

        /// <summary>
        /// List of supported HTTP methods when making HTTP requests to the Expressly REST API.
        /// </summary>
        protected internal enum HttpMethod
        {
            /// <summary>
            /// GET HTTP request. This is typically used in API operations to retrieve a static resource.
            /// </summary>
            GET,

            /// <summary>
            /// HEAD HTTP request. This is typically used to retrieve only the header information for a static resource.
            /// </summary>
            HEAD,

            /// <summary>
            /// POST HTTP request. This is typically used in API operations that require data in the request body to complete.
            /// </summary>
            POST,

            /// <summary>
            /// PUT HTTP request. This is used in some API operations that update a given resource.
            /// </summary>
            PUT,

            /// <summary>
            /// DELETE HTTP request. This is typcially used in API oeprations that delete a given resource.
            /// </summary>
            DELETE,

            /// <summary>
            /// PATCH HTTP request. This is typcially used in API operations that update a given resource.
            /// </summary>
            PATCH
        }

        /// <summary>
        /// Gets the last request sent by the SDK in the current thread.
        /// </summary>
        public static ThreadLocal<RequestDetails> LastRequestDetails { get; private set; }

        /// <summary>
        /// Gets the last response received by the SDK in the current thread.
        /// </summary>
        public static ThreadLocal<ResponseDetails> LastResponseDetails { get; private set; }

        /// <summary>
        /// Static constructor initializing any static properties.
        /// </summary>
        static ExpresslyClient()
        {
            LastRequestDetails = new ThreadLocal<RequestDetails>();
            LastResponseDetails = new ThreadLocal<ResponseDetails>();
        }

        /// <summary>
        /// Configures and executes REST call: Supports JSON
        /// </summary>
        /// <param name="apiContext">APIContext object</param>
        /// <param name="httpMethod">HttpMethod type</param>
        /// <param name="resource">URI path of the resource</param>
        /// <param name="payload">JSON request payload</param>
        /// <param name="endpoint">Optional endpoint to use when generating the full URL for the resource. If none is specified, a default endpoint is generated by the SDK based on other config settings.</param>
        /// <param name="setAuthorizationHeader">Specifies whether or not to set the Authorization header in outgoing requests. Defaults to true.</param>
        /// <returns>Response object or null otherwise for void API calls</returns>
        /// <exception cref="Expressly.HttpException">Thrown if there was an error sending the request.</exception>
        /// <exception cref="Expressly.ExpresslyException">Thrown for any other issues encountered. See inner exception for further details.</exception>
        protected internal static object ConfigureAndExecute(APIContext apiContext, HttpMethod httpMethod, string resource, string payload = "", string endpoint = "", bool setAuthorizationHeader = true)
        {
            return ConfigureAndExecute<object>(apiContext, httpMethod, resource, payload, endpoint, setAuthorizationHeader);
        }

        /// <summary>
        /// Configures and executes REST call: Supports JSON
        /// </summary>
        /// <typeparam name="T">Generic Type parameter for response object</typeparam>
        /// <param name="apiContext">APIContext object</param>
        /// <param name="httpMethod">HttpMethod type</param>
        /// <param name="resource">URI path of the resource</param>
        /// <param name="payload">JSON request payload</param>
        /// <param name="endpoint">Endpoint to use when generating the full URL for the resource. If none is specified, a default endpoint is generated by the SDK based on other config settings.</param>
        /// <param name="setAuthorizationHeader">Specifies whether or not to set the Authorization header in outgoing requests. Defaults to true.</param>
        /// <returns>Response object or null otherwise for void API calls</returns>
        /// <exception cref="Expressly.HttpException">Thrown if there was an error sending the request.</exception>
        /// <exception cref="Expressly.ExpresslyException">Thrown for any other issues encountered. See inner exception for further details.</exception>
        protected internal static T ConfigureAndExecute<T>(APIContext apiContext, HttpMethod httpMethod, string resource, string payload = "", string endpoint = "", bool setAuthorizationHeader = true)
        {
            // Verify the state of the APIContext object.
            if (apiContext == null)
            {
                throw new ExpresslyException("APIContext object is null");
            }

            try
            {
                var config = apiContext.GetConfigWithDefaults();
                var headersMap = GetHeaderMap(apiContext);

                if (!setAuthorizationHeader && headersMap.ContainsKey(BaseConstants.AuthorizationHeader))
                {
                    headersMap.Remove(BaseConstants.AuthorizationHeader);
                }

                if (string.IsNullOrEmpty(endpoint))
                {
                    endpoint = GetEndpoint(config);
                }

                // Create the URI where the HTTP request will be sent.
                Uri uniformResourceIdentifier = null;
                var baseUri = new Uri(endpoint);
                if (!Uri.TryCreate(baseUri, resource, out uniformResourceIdentifier))
                {
                    throw new ExpresslyException("Cannot create URL; baseURI=" + baseUri.ToString() + ", resourcePath=" + resource);
                }

                // Create the HttpRequest object that will be used to send the HTTP request.
                var connMngr = ConnectionManager.Instance;
                var httpRequest = connMngr.GetConnection(config, uniformResourceIdentifier.ToString());
                httpRequest.Method = httpMethod.ToString();

                // Set custom content type (default to [application/json])
                if (headersMap != null && headersMap.ContainsKey(BaseConstants.ContentTypeHeader))
                {
                    httpRequest.ContentType = headersMap[BaseConstants.ContentTypeHeader].Trim();
                    headersMap.Remove(BaseConstants.ContentTypeHeader);
                }
                else
                {
                    httpRequest.ContentType = BaseConstants.ContentTypeHeaderJson;
                }

                // Set User-Agent HTTP header
                if (headersMap.ContainsKey(BaseConstants.UserAgentHeader))
                {
                    //iso-8859-1
                    var iso8851 = Encoding.GetEncoding("iso-8859-1", new EncoderReplacementFallback(string.Empty), new DecoderExceptionFallback());
                    var bytes = Encoding.Convert(Encoding.UTF8, iso8851, Encoding.UTF8.GetBytes(headersMap[BaseConstants.UserAgentHeader]));
                    httpRequest.UserAgent = iso8851.GetString(bytes);
                    headersMap.Remove(BaseConstants.UserAgentHeader);
                }

                // Set Custom HTTP headers
                foreach (KeyValuePair<string, string> entry in headersMap)
                {
                    httpRequest.Headers.Add(entry.Key, entry.Value);
                }

                // Log the headers
                foreach (string headerName in httpRequest.Headers)
                {
                    logger.DebugFormat(headerName + ":" + httpRequest.Headers[headerName]);
                }

                // Execute call
                var connectionHttp = new HttpConnection(config);

                // Setup the last request & response details.
                LastRequestDetails.Value = connectionHttp.RequestDetails;
                LastResponseDetails.Value = connectionHttp.ResponseDetails;

                var response = connectionHttp.Execute(payload, httpRequest);


                if (connectionHttp.ResponseDetails.StatusCode == HttpStatusCode.NoContent)
                {
                    return (T)Convert.ChangeType((int)HttpStatusCode.NoContent, typeof(T));
                }

                else if (typeof(T).Name.Equals("Object"))
                {
                    return default(T);
                }
                else if (typeof(T).Name.Equals("String"))
                {
                    return (T)Convert.ChangeType(response, typeof(T));
                }

                return JsonFormatter.ConvertFromJson<T>(response);
            }
            catch (ExpresslyException)
            {
                // If we get a ExpresslyException, just rethrow to preserve the stack trace.
                throw;
            }
            catch (System.Exception ex)
            {
                throw new ExpresslyException(ex.Message, ex);
            }
        }

        /// <summary>
        /// Gets a collection of headers to be used in an HTTP request.
        /// </summary>
        /// <param name="apiContext">APIContext object containing information needed to construct the headers map.</param>
        /// <returns>A collection of headers.</returns>
        public static Dictionary<string, string> GetHeaderMap(APIContext apiContext)
        {
            var headers = new Dictionary<string, string>();
            var config = apiContext.GetConfigWithDefaults();
            var apiKey = config.ContainsKey(BaseConstants.ApiKey) ? config[BaseConstants.ApiKey] : null;
            headers[BaseConstants.AuthorizationHeader] = "Basic " + apiKey;

            // Add any custom headers
            if (apiContext.HTTPHeaders != null && apiContext.HTTPHeaders.Count > 0)
            {
                foreach (var header in apiContext.HTTPHeaders)
                {
                    headers[header.Key] = header.Value;
                }
            }
            return headers;
        }

        /// <summary>
        /// Gets the endpoint to be used when making an HTTP call to the REST API.
        /// </summary>
        /// <returns>The endpoint to be used when making an HTTP call to the REST API.</returns>
        public static string GetEndpoint(Dictionary<string, string> config)
        {
            string endpoint = null;

            // Try and load the endpoint from the config.
            if (config.ContainsKey(BaseConstants.EndpointConfig))
            {
                endpoint = config[BaseConstants.EndpointConfig];
            }
            else if (config.ContainsKey(BaseConstants.ApplicationModeConfig))
            {
                switch (config[BaseConstants.ApplicationModeConfig])
                {
                    case BaseConstants.LiveMode:
                        endpoint = BaseConstants.RESTLiveEndpoint;
                        break;
                    case BaseConstants.SandboxMode:
                        endpoint = BaseConstants.RESTSandboxEndpoint;
                        break;
                }
            }

            // If no endpoint is defined, then default to sandbox.
            if (string.IsNullOrEmpty(endpoint))
            {
                endpoint = BaseConstants.RESTSandboxEndpoint;
            }

            if (!endpoint.EndsWith("/"))
            {
                endpoint += "/";
            }

            return endpoint;
        }

    }
}
